동적 메모리 할당

1. 정적 메모리 할당
    - 메모리가 자동으로 할당되고 해제되는 방식

2. 동적 메모리 할당
    1) 컴파일 시에 메모리를 결정하는것이 아닌 런 타임 시에 결정하는 방식

    2) 함수

        (1) malloc
            - 메모리 할당에 실패할 경우 NULL을 반환한다
            - NULL 을 대상으로 연산을 수행하면 예외가 발생하여 강제로 종료된다
            - 따라서 안전한 프로그래밍을 위하여 malloc의 반환값이 NULL인지 확인해야한다


            ※ malloc 함수 원형
                void* malloc(size_t size);

            ※ 자료형
                - size_t : 할당받을 메모리의 크기, 바이트 단위이다
                - void* : 할당받은 메모리의 시작 주소를 가리키는 포인터이다

            ※ 메모리 할당에 실패할 경우
                - 새로 할당할 수 있는 남은 메모리가 없을 때
                - 운영체제가 감당할 수 없는 크기의 메모리를 요구할 때
                - 개발자가 실수로 인수를 0으로 하고 함수를 호출할 때
        (2) free : 메모리 해제 함수
            ※ free 함수 원형
                void free(void* memblock);
3. 메모리 해제는 반드시 필요한가?
    1) 반드시 필요하다
        - 해제하지 않은 메모리는 프로그램이 종료될 때까지 재사용할 수 없기 때문이다.
        - 즉, 메모리 누수가 발생

4. 메모리 구조화 할당방식
    1) 전역 자료 영역
        - 전역 자료 영역에는 전역 변수나 정적 변수로 선언된 메모리가 지정되는 곳
        - 프로그램이 끝날 때까지 해제되지 않는다
    2) 힙(heap) 영역
        - 힙 영역은 동적으로 할당받은 변수들이 저장된다
        - 단, 힙 영역에 할당받은 메모리는 free() 함수 등으로 해제하지 안흥면 프로그램이 종료될 때까지 반환되지 않는다
    3) 스택(stack) 영역
        - 스택 영역은 함수 내부에서 선언된 변수나 배열이 저장되는 영역이다
        - 스택 영역의 변수들은 따로 메모리를 해제하지 않아도, 해당 함수가 끝나면 자동으로 운영체제에 반환된다
        ※ 단, 스택 영역에 선언된 변수들은 컴파일 시에 그 크기가 미리 정해져있어야 한다.
            그렇지 않으면 함수가 끝난 다음 얼마만큼의 메모리를 반환해야 할지 모르기 때문이다

5. 할당받은 메모리의 초기화
    1) 동적 메모리 할당
        - 단순히 할당만 받으면 할당받은 메모리는 쓰레기 값으로 채워지기 때문에, 0으로 초기화하는 작업이 추가로 필요하다
        - 일반적인 방법으로 0으로 초기화하기는 어렵기때문에 memset() 이라는 함수를 사용한다

        ※ memset() : 특정 메모리의 값을 임의의 숫자로 초기화하는 함수
            - 함수 원형
                #include <string.h>
                void* memset(void* dest, int c, size_t count);
    1) 메모리 할당과 동시에 초기화

        (1) calloc() : 메모리 할당과 동시에 초기화하는 함수
            - 함수 원형 
                #include <stdlib.h>
                void* calloc(size_t num, size_t size);
        (2) malloc() 함수와 마찬가지로 보통은 사용하려는 자료형으로 형변환 하여 포인터 변수에 대입한다

6. 기존에 할당된 메모리 공간을 확장
    1) realloc() : 기존에 할당받은 메모리를 확장이나 축소할 때 사용하는 함수
        - 함수 원형
            #include <stdlib.h>
            void* realloc(void* memblock, size_t size);
    2) 메모리를 확장하려면 기존의 할당 받았던 메모리 크기보다 더 커야 한다
        그렇지 않으면 메모리가 축소된다.
    3) malloc() 함수와 마찬가지로 보통은 사용하려는 자료형으로 형변환 하여 포인터 변수에 대입한다
    
    4) 동작 방식
        (1) realloc() 함수는 가능하면 기존 메모리 주소를 기반으로 메모리 확장을 시도한다
            - 기존의 메모리 시작 주소를 기반으로 메모리를 확장하는 것에 성공하면 반환되는 주솟값이 기존의 메모리 시작 주소와 같다
        (2) 실패 할 경우 새로운 주소를 시작으로 메모리를 확장한다
            - 확장된 전체 메모리 크리고 새롭게 할당받는 것이다
            - 그리고 새롭게 할당받은 메모리에 기존의 메모리를 복사한다
            - 확장에 성공하면 반환되는 메모리의 시작주소가 기존의 메모리 시작주소와 다르다
            - 기존의 할당된 메모리는 해제된다 ( 기존의 메모리를 해제하려고 하면 프로그램이 강제로 종료될 수 있다 )

        ※ 새로운 주소로 확장되면 기존 주소를 가리키는 포인터 변수들을 모두 새 주소를 가리키도록 수정해야 한다
            기존 주소에 있는 메모리는 이미 해제되었기 때문이다
            이처럼 이미 해제된 메모리를 가리키는 포인터를 댕글링 포인터(dangling pointer)라고 한다

            - 단, realloc() 함수가 NULL를 반환하여 메모리 확장에 실패하면 기존에 할당받았떤 메모리는 해제되지 않는다.